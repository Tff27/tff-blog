---
draft: true
slug: understanding-what-observability-is
title: Understanding what Observability is
date: 2022-12-20T19:00:00.000+00:00
image: "/images/three_pillars.png"
tags:
- '0'
- '4'
description: "Observability is the ability to understand the internal state of a system
  based on its external outputs. \nIt is an important concept that allows engineers
  to monitor and diagnose the performance and behaviour of their systems, and to identify
  and fix issues before they become major problems."

---
Observability is a term that is commonly used in the field of software engineering and refers to the ability to understand the internal state of a system based on its external outputs. It is an important concept that allows engineers to monitor and diagnose the performance and behavior of their systems, and to identify and fix issues before they become major problems.

Observability is typically achieved through the use of three main pillars: metrics, logging, and tracing. These pillars work together to provide a comprehensive view of the system and to enable engineers to understand and improve its behavior.

## Logging

Logging refers to the process of recording events and messages generated by a system. These logs can include information about system errors, performance issues, user actions, and other important events. Logs are typically stored in a central location, such as a log server or cloud storage, and can be searched, filtered, and analyzed to identify and understand the causes of issues.

### How to get started with logging in .net 7:

    // Use the ILogger interface that derives from your specific type 
    private readonly ILogger<WeatherForecastController> _logger;
    
    public WeatherForecastController(ILogger<WeatherForecastController> logger)
    {
    	_logger = logger; // Make sure your logger is initialized by DI
    }
    
    [HttpGet("GetWeatherForecastWithLogs", Name = "GetWeatherForecastWithLogs")]
    public IEnumerable<WeatherForecast> GetWithLogs()
    {
    	// Add controller information to log scope
    	using (_logger.BeginScope("WeatherForecastController Scope"))
    	{
            // Log with different levels
            _logger.LogInformation("Get a weather forecast with logs");
            _logger.LogWarning("Get a weather forecast with logs");
            _logger.LogError("Get a weather forecast with logs");
            // There are other levels available such as Debug, Critical and Trace
    
            return Enumerable.Range(1, 5).Select(index => new WeatherForecast
            {
                Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),
                TemperatureC = Random.Shared.Next(-20, 55),
                Summary = Summaries[Random.Shared.Next(Summaries.Length)]
            })
            .ToArray();
    	}
    }

If no other configurations are done you should see your logs coming up in your console keep in mind that you are only seeing logs that are in or above the level you set on your configurations.

The following code logs everything with the log level "Information" and above for everything in your app except for "Microsoft.AspNetCore" logs that are only recorded if they are a "Warning" or above.

    {
      "Logging": {
        "LogLevel": {
          "Default": "Information",
          "Microsoft.AspNetCore": "Warning"
        }
      }
    }

## Metrics

Metrics are numerical measurements of the performance and behavior of a system. Examples of metrics include the number of requests per second, the average response time, and the number of errors. Metrics are often collected in real-time and displayed in graphs or dashboards, allowing engineers to quickly and easily identify trends and patterns in the data.

### How to get started with metrics in .net 7:

    // Create Meter
    private static Meter meter = new Meter(Constants.MeterName, "v1.0");
    // Create counter
    private static Counter<int> counter = meter.CreateCounter<int>("Requests");
    
    [HttpGet("GetWeatherForecastWithMetrics", Name = "GetWeatherForecastWithMetrics")]
    public IEnumerable<WeatherForecast> GetWithMetrics()
    {
    	// Increase the metric counter
    	counter.Add(1);
    
        return Enumerable.Range(1, 5).Select(index => new WeatherForecast
        {
            Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),
            TemperatureC = Random.Shared.Next(-20, 55),
            Summary = Summaries[Random.Shared.Next(Summaries.Length)]
        })
        .ToArray();
    }

## Tracing

Tracing refers to the process of tracking the flow of a request through a distributed system. This can include information about the different components, services, and networks that the request touches, as well as the time it takes for the request to be processed. Tracing allows engineers to see the complete picture of a request's handling, from end to end, and identify bottlenecks and other performance issues.

### How to get started with tracing in .net 7:

    // Create a new activity source
    private static ActivitySource source = new ActivitySource(Constants.ActivitySourceName, "1.0.0");
    
    [HttpGet("GetWeatherForecastWithTracing", Name = "GetWeatherForecastWithTracing")]
    public IEnumerable<WeatherForecast> GetWithTracing()
    {
        // Create a new activity
        using Activity activity = source.StartActivity("GetWeatherForecastWithTracing", ActivityKind.Internal);
        activity?.AddTag("Method", "GetWeatherForecastWithTracing");
    
        var wf1 = GenerateWeatherForecast("Get WeatherForecast (1)");
        var wf2 = GenerateWeatherForecast("Get WeatherForecast (2)");
    
        // Signal that activity ended
        activity?.Stop();
    
        return wf1.Concat(wf2).ToArray();
    }
    
    static WeatherForecast[] GenerateWeatherForecast(string activityName)
    {
        // Create a new activity
        using Activity activity = source.StartActivity(activityName, ActivityKind.Internal);
    
        var weatherForecasts = Enumerable.Range(1, 5).Select(index => new WeatherForecast
        {
            Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),
            TemperatureC = Random.Shared.Next(-20, 55),
            Summary = Summaries[Random.Shared.Next(Summaries.Length)]
        })
        .ToArray();
    
        // Signal that activity ended
        activity?.Stop();
    
        return weatherForecasts;
    }

[OpenTelemetry](https://opentelemetry.io/ "OpenTelemetry") **NuGet packages that are required are still in pre-release!** 

    OpenTelemetry
    OpenTelemetry.Exporter.Console
    OpenTelemetry.Extensions.Hosting
    OpenTelemetry.Instrumentation.AspNetCore

## Let's have the logs, metrics and traces in the console

If you want to check all of your work in the console you will need to configure the metrics and traces [OpenTelemetry](https://opentelemetry.io/ "OpenTelemetry") exporters.

Add the following to your Program.cs:

    builder.Services.AddOpenTelemetry()
        .WithTracing(builder =>
        {
            builder.AddAspNetCoreInstrumentation();
            builder.AddConsoleExporter();
            builder.AddSource(Constants.ActivitySourceName);
        })
        .WithMetrics(builder =>
        {
            builder.AddAspNetCoreInstrumentation();
            builder.AddConsoleExporter();
            builder.AddMeter(Constants.MeterName);
        })
        .StartWithHost();

## Conclusion

Together, these three pillars of observability provide a comprehensive view of a system and enable engineers to understand and improve its behavior. By implementing observability, engineers can monitor and diagnose issues as soon as possible, and take proactive steps to prevent and fix problems before they impact users.